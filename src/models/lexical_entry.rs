/*
 *
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.11.0
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// LexicalEntry : Description of an entry for a particular part of speech

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct LexicalEntry {
  /// Other words from which this one derives
  #[serde(rename = "derivativeOf")]
  derivative_of: Option<::models::ArrayOfRelatedEntries>,
  /// Other words from which their Sense derives
  #[serde(rename = "derivatives")]
  derivatives: Option<Vec<::models::Derivative>>,
  #[serde(rename = "entries")]
  entries: Option<Vec<::models::Entry>>,
  #[serde(rename = "grammaticalFeatures")]
  grammatical_features: Option<::models::GrammaticalFeaturesList>,
  /// IANA language code
  #[serde(rename = "language")]
  language: String,
  /// A linguistic category of words (or more precisely lexical items), generally defined by the syntactic or morphological behaviour of the lexical item in question, such as noun or verb
  #[serde(rename = "lexicalCategory")]
  lexical_category: String,
  #[serde(rename = "notes")]
  notes: Option<::models::CategorizedTextList>,
  #[serde(rename = "pronunciations")]
  pronunciations: Option<Vec<::models::PronunciationsListInner>>,
  /// A given written or spoken realisation of a an entry.
  #[serde(rename = "text")]
  text: String,
  /// Various words that are used interchangeably depending on the context, e.g 'a' and 'an'
  #[serde(rename = "variantForms")]
  variant_forms: Option<::models::VariantFormsList>,
}

impl LexicalEntry {
  /// Description of an entry for a particular part of speech
  pub fn new(language: String, lexical_category: String, text: String) -> LexicalEntry {
    LexicalEntry {
      derivative_of: None,
      derivatives: None,
      entries: None,
      grammatical_features: None,
      language: language,
      lexical_category: lexical_category,
      notes: None,
      pronunciations: None,
      text: text,
      variant_forms: None,
    }
  }

  pub fn set_derivative_of(&mut self, derivative_of: ::models::ArrayOfRelatedEntries) {
    self.derivative_of = Some(derivative_of);
  }

  pub fn with_derivative_of(
    mut self,
    derivative_of: ::models::ArrayOfRelatedEntries,
  ) -> LexicalEntry {
    self.derivative_of = Some(derivative_of);
    self
  }

  pub fn derivative_of(&self) -> Option<&::models::ArrayOfRelatedEntries> {
    self.derivative_of.as_ref()
  }

  pub fn reset_derivative_of(&mut self) {
    self.derivative_of = None;
  }

  pub fn set_derivatives(&mut self, derivatives: Vec<::models::Derivative>) {
    self.derivatives = Some(derivatives);
  }

  pub fn with_derivatives(mut self, derivatives: Vec<::models::Derivative>) -> LexicalEntry {
    self.derivatives = Some(derivatives);
    self
  }

  pub fn derivatives(&self) -> Option<&Vec<::models::Derivative>> {
    self.derivatives.as_ref()
  }

  pub fn reset_derivatives(&mut self) {
    self.derivatives = None;
  }

  pub fn set_entries(&mut self, entries: Vec<::models::Entry>) {
    self.entries = Some(entries);
  }

  pub fn with_entries(mut self, entries: Vec<::models::Entry>) -> LexicalEntry {
    self.entries = Some(entries);
    self
  }

  pub fn entries(&self) -> Option<&Vec<::models::Entry>> {
    self.entries.as_ref()
  }

  pub fn reset_entries(&mut self) {
    self.entries = None;
  }

  pub fn set_grammatical_features(
    &mut self,
    grammatical_features: ::models::GrammaticalFeaturesList,
  ) {
    self.grammatical_features = Some(grammatical_features);
  }

  pub fn with_grammatical_features(
    mut self,
    grammatical_features: ::models::GrammaticalFeaturesList,
  ) -> LexicalEntry {
    self.grammatical_features = Some(grammatical_features);
    self
  }

  pub fn grammatical_features(&self) -> Option<&::models::GrammaticalFeaturesList> {
    self.grammatical_features.as_ref()
  }

  pub fn reset_grammatical_features(&mut self) {
    self.grammatical_features = None;
  }

  pub fn set_language(&mut self, language: String) {
    self.language = language;
  }

  pub fn with_language(mut self, language: String) -> LexicalEntry {
    self.language = language;
    self
  }

  pub fn language(&self) -> &String {
    &self.language
  }

  pub fn set_lexical_category(&mut self, lexical_category: String) {
    self.lexical_category = lexical_category;
  }

  pub fn with_lexical_category(mut self, lexical_category: String) -> LexicalEntry {
    self.lexical_category = lexical_category;
    self
  }

  pub fn lexical_category(&self) -> &String {
    &self.lexical_category
  }

  pub fn set_notes(&mut self, notes: ::models::CategorizedTextList) {
    self.notes = Some(notes);
  }

  pub fn with_notes(mut self, notes: ::models::CategorizedTextList) -> LexicalEntry {
    self.notes = Some(notes);
    self
  }

  pub fn notes(&self) -> Option<&::models::CategorizedTextList> {
    self.notes.as_ref()
  }

  pub fn reset_notes(&mut self) {
    self.notes = None;
  }

  pub fn set_pronunciations(&mut self, pronunciations: Vec<::models::PronunciationsListInner>) {
    self.pronunciations = Some(pronunciations);
  }

  pub fn with_pronunciations(
    mut self,
    pronunciations: Vec<::models::PronunciationsListInner>,
  ) -> LexicalEntry {
    self.pronunciations = Some(pronunciations);
    self
  }

  pub fn pronunciations(&self) -> Option<&Vec<::models::PronunciationsListInner>> {
    self.pronunciations.as_ref()
  }

  pub fn reset_pronunciations(&mut self) {
    self.pronunciations = None;
  }

  pub fn set_text(&mut self, text: String) {
    self.text = text;
  }

  pub fn with_text(mut self, text: String) -> LexicalEntry {
    self.text = text;
    self
  }

  pub fn text(&self) -> &String {
    &self.text
  }

  pub fn set_variant_forms(&mut self, variant_forms: ::models::VariantFormsList) {
    self.variant_forms = Some(variant_forms);
  }

  pub fn with_variant_forms(mut self, variant_forms: ::models::VariantFormsList) -> LexicalEntry {
    self.variant_forms = Some(variant_forms);
    self
  }

  pub fn variant_forms(&self) -> Option<&::models::VariantFormsList> {
    self.variant_forms.as_ref()
  }

  pub fn reset_variant_forms(&mut self) {
    self.variant_forms = None;
  }
}
